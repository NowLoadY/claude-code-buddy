# Phase 0.6: Enhanced Automatic Memory System

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Upgrade existing automatic memory system to capture task intentions, decisions, and progress milestones - enabling CCB to remember "what we're working on", "why we're doing it", and "where we are" without manual intervention.

**Approach:** Extend existing `HookIntegration` + `ProjectAutoTracker` with new checkpoint types and memory categories. Integrate with `buddy-do` workflow for task start capture.

**Tech Stack:** TypeScript, existing Knowledge Graph, MCP tools

---

## üìä Current Auto-Memory System Analysis

### ‚úÖ What We Have

**1. HookIntegration.ts** - Automatic checkpoint detection:
- `code-written` - Detects Write/Edit tools
- `test-complete` - Detects test commands
- `commit-ready` - Detects git add
- `committed` - Detects git commit

**2. ProjectAutoTracker.ts** - Automatic memory recording:
- Event-driven memories (tests, commits, checkpoints)
- Aggregated code changes (2-minute window)
- Token-based snapshots (every 10k tokens)
- Memory deduplication (5-minute merge window)

**3. buddy-record-mistake** - Manual error recording

### ‚ùå What We're Missing

**1. Task Start Memory** - No record of:
- What we're trying to achieve (goal)
- Why we're doing it (reason/context)
- What success looks like (expected outcome)

**2. Decision Memory** - No automatic capture of:
- Important technical decisions
- Alternatives considered
- Reasoning behind choices

**3. Progress Milestones** - Only low-level checkpoints:
- Missing high-level progress tracking
- No "% complete" or "next steps" tracking
- No blocking issues capture

**4. Auto Error Recording** - `buddy-record-mistake` is manual:
- Should auto-detect from failed tools
- Should auto-extract from systematic-debugging skill output

---

## üéØ Enhancement Plan

### Phase 0.6 Enhancements

**1. Add New Checkpoint Types** (to HookIntegration)
- `task-started` - Task begin with goal/reason
- `decision-made` - Important technical decisions
- `milestone-reached` - High-level progress points
- `error-encountered` - Automatic error detection

**2. Extend ProjectAutoTracker** (new memory categories)
- `recordTaskStart()` - Capture task metadata
- `recordDecision()` - Capture decisions
- `recordMilestone()` - Track progress
- `recordError()` - Auto-record errors

**3. Integrate with buddy-do**
- Auto-trigger `task-started` checkpoint
- Extract goal/reason from task description
- Generate expected outcome

**4. Auto-Detect Errors**
- Hook into failed tool executions
- Extract error patterns
- Auto-record to Knowledge Graph

---

## üìã Implementation Tasks

### Task 1: Add Task Start Tracking (~3 hours)

**Goal:** Automatically record "what we're doing" and "why" when tasks start

**Files:**
- Modify: `src/core/HookIntegration.ts` (add `task-started` checkpoint)
- Modify: `src/memory/ProjectAutoTracker.ts` (add `recordTaskStart()`)
- Modify: `src/mcp/tools/buddy-do.ts` (integrate trigger)

**New checkpoint type:**
```typescript
// In HookIntegration.ts
interface TaskStartCheckpoint {
  name: 'task-started';
  data: {
    task_description: string;
    goal: string;           // Extracted from description
    reason?: string;        // Extracted from description
    expected_outcome?: string;
    priority: 'low' | 'normal' | 'high' | 'critical';
    related_files?: string[];
  };
}
```

**Memory structure:**
```typescript
// In ProjectAutoTracker.ts
async recordTaskStart(data: {
  task_description: string;
  goal: string;
  reason?: string;
  expected_outcome?: string;
  priority?: string;
}): Promise<void> {
  const timestamp = new Date().toISOString();
  const dateStr = timestamp.split('T')[0];

  await this.mcp.createEntities([{
    name: `Task Started: ${data.goal} - ${dateStr}`,
    entityType: 'task_start',
    observations: [
      `GOAL: ${data.goal}`,
      data.reason ? `REASON: ${data.reason}` : '',
      `TASK: ${data.task_description}`,
      data.expected_outcome ? `EXPECTED: ${data.expected_outcome}` : '',
      data.priority ? `PRIORITY: ${data.priority}` : '',
    ].filter(Boolean),
    metadata: {
      timestamp,
      priority: data.priority || 'normal',
      task_description: data.task_description,
    },
  }]);
}
```

**Integration with buddy-do:**
```typescript
// In buddy-do.ts
export async function executeBuddyDo(
  input: ValidatedBuddyDoInput,
  router: Router,
  hookIntegration: HookIntegration  // NEW parameter
): Promise<string> {
  // Extract goal and reason from task description
  const taskMeta = extractTaskMetadata(input.task);

  // AUTO-TRIGGER: Task Started checkpoint
  await hookIntegration.processToolUse({
    toolName: 'TaskStart',  // Virtual tool
    arguments: {
      task_description: input.task,
      goal: taskMeta.goal,
      reason: taskMeta.reason,
      expected_outcome: taskMeta.expectedOutcome,
      priority: input.priority || 'normal',
    },
    success: true,
  });

  // Existing routing logic...
  const analysis = await router.analyzeTask(input.task);
  const result = await router.route(analysis);

  return formatted;
}

/**
 * Extract goal, reason, expected outcome from task description
 * Uses simple heuristics and patterns
 */
function extractTaskMetadata(task: string): {
  goal: string;
  reason?: string;
  expectedOutcome?: string;
} {
  // Simple extraction logic:
  // - Goal: First sentence or "to X" pattern
  // - Reason: "because X", "so that X" patterns
  // - Expected: "should X", "will X" patterns

  const goalMatch = task.match(/^([^.!?]+)[.!?]/) || task.match(/to ([^,]+)/);
  const reasonMatch = task.match(/because ([^,]+)/) || task.match(/so that ([^,]+)/);
  const expectedMatch = task.match(/should ([^,]+)/) || task.match(/will ([^,]+)/);

  return {
    goal: goalMatch?.[1] || task.substring(0, 100),
    reason: reasonMatch?.[1],
    expectedOutcome: expectedMatch?.[1],
  };
}
```

**Acceptance:**
- [ ] Starting a task via buddy-do creates `task_start` entity
- [ ] Goal extracted from description
- [ ] Memory includes GOAL, REASON, EXPECTED, PRIORITY
- [ ] Manual test: start task, verify memory created

---

### Task 2: Add Decision Tracking (~3 hours)

**Goal:** Automatically capture important decisions

**Files:**
- Modify: `src/core/HookIntegration.ts` (add `decision-made` checkpoint)
- Modify: `src/memory/ProjectAutoTracker.ts` (add `recordDecision()`)
- Create: `src/mcp/tools/record-decision.ts` (manual trigger tool)

**New MCP tool:** `ccb-record-decision`

```typescript
// In ToolDefinitions.ts
const recordDecisionTool: MCPToolDefinition = {
  name: 'ccb-record-decision',
  description: 'Record an important technical or architectural decision with reasoning and alternatives considered',
  inputSchema: {
    type: 'object',
    properties: {
      decision: {
        type: 'string',
        description: 'What was decided',
      },
      alternatives: {
        type: 'array',
        items: { type: 'string' },
        description: 'Other options considered (optional)',
      },
      reasoning: {
        type: 'string',
        description: 'Why this option was chosen',
      },
      impact: {
        type: 'string',
        description: 'Expected impact or implications (optional)',
      },
    },
    required: ['decision', 'reasoning'],
  },
};
```

**Memory structure:**
```typescript
// In ProjectAutoTracker.ts
async recordDecision(data: {
  decision: string;
  alternatives?: string[];
  reasoning: string;
  impact?: string;
}): Promise<void> {
  const timestamp = new Date().toISOString();
  const dateStr = timestamp.split('T')[0];

  const observations: string[] = [
    `DECISION: ${data.decision}`,
    `REASONING: ${data.reasoning}`,
  ];

  if (data.alternatives && data.alternatives.length > 0) {
    observations.push('ALTERNATIVES:');
    data.alternatives.forEach(alt => {
      observations.push(`  - ${alt}`);
    });
  }

  if (data.impact) {
    observations.push(`IMPACT: ${data.impact}`);
  }

  await this.mcp.createEntities([{
    name: `Decision: ${data.decision.substring(0, 50)} - ${dateStr}`,
    entityType: 'decision',
    observations,
    metadata: {
      timestamp,
      decision: data.decision,
      alternatives: data.alternatives,
      reasoning: data.reasoning,
      impact: data.impact,
    },
  }]);
}
```

**Usage in code-reviewer skill:**
```markdown
## After making architecture decisions:

Use CCB to record the decision:
```
ccb-record-decision with:
- decision: "Use SQLite for Task Queue instead of Knowledge Graph"
- alternatives: ["Use Knowledge Graph", "In-memory queue", "Redis"]
- reasoning: "Knowledge Graph is for long-term memory, not real-time task communication"
- impact: "Task Queue can scale independently, cleaner architecture"
```
```

**Acceptance:**
- [ ] `ccb-record-decision` tool works
- [ ] Creates `decision` entity with alternatives and reasoning
- [ ] Manual test: record a decision, verify memory

---

### Task 3: Add Progress Milestone Tracking (~2 hours)

**Goal:** Track high-level progress ("Task 3/10 complete", "Blocked on X")

**Files:**
- Modify: `src/memory/ProjectAutoTracker.ts` (add `recordMilestone()`)
- Create: `src/mcp/tools/record-milestone.ts`

**New MCP tool:** `ccb-record-milestone`

```typescript
const recordMilestoneTool: MCPToolDefinition = {
  name: 'ccb-record-milestone',
  description: 'Record a progress milestone (e.g., "Task 3/10 complete", "Feature implemented")',
  inputSchema: {
    type: 'object',
    properties: {
      milestone: {
        type: 'string',
        description: 'What was achieved',
      },
      progress_percentage: {
        type: 'number',
        description: 'Overall progress (0-100, optional)',
      },
      next_steps: {
        type: 'array',
        items: { type: 'string' },
        description: 'What comes next (optional)',
      },
      blockers: {
        type: 'array',
        items: { type: 'string' },
        description: 'Current blockers (optional)',
      },
      learnings: {
        type: 'array',
        items: { type: 'string' },
        description: 'Key learnings from this milestone (optional)',
      },
    },
    required: ['milestone'],
  },
};
```

**Memory structure:**
```typescript
async recordMilestone(data: {
  milestone: string;
  progress_percentage?: number;
  next_steps?: string[];
  blockers?: string[];
  learnings?: string[];
}): Promise<void> {
  const timestamp = new Date().toISOString();
  const dateStr = timestamp.split('T')[0];

  const observations: string[] = [
    `MILESTONE: ${data.milestone}`,
  ];

  if (data.progress_percentage !== undefined) {
    observations.push(`PROGRESS: ${data.progress_percentage}%`);
  }

  if (data.next_steps && data.next_steps.length > 0) {
    observations.push('NEXT STEPS:');
    data.next_steps.forEach(step => {
      observations.push(`  - ${step}`);
    });
  }

  if (data.blockers && data.blockers.length > 0) {
    observations.push('BLOCKERS:');
    data.blockers.forEach(blocker => {
      observations.push(`  - ${blocker}`);
    });
  }

  if (data.learnings && data.learnings.length > 0) {
    observations.push('LEARNINGS:');
    data.learnings.forEach(learning => {
      observations.push(`  - ${learning}`);
    });
  }

  await this.mcp.createEntities([{
    name: `Milestone: ${data.milestone} - ${dateStr}`,
    entityType: 'progress_milestone',
    observations,
    metadata: {
      timestamp,
      milestone: data.milestone,
      progress_percentage: data.progress_percentage,
      next_steps: data.next_steps,
      blockers: data.blockers,
      learnings: data.learnings,
    },
  }]);
}
```

**Integration with executing-plans skill:**
```markdown
## After completing each major task:

Use CCB to record milestone:
```
ccb-record-milestone with:
- milestone: "Task 2/10: Task Queue Storage Implemented"
- progress_percentage: 20
- next_steps: ["Implement Agent Registry (Task 3)"]
- learnings: ["better-sqlite3 requires explicit schema init", "WAL mode improves concurrency"]
```
```

**Acceptance:**
- [ ] `ccb-record-milestone` tool works
- [ ] Creates `progress_milestone` entity
- [ ] Manual test: record milestone, verify memory

---

### Task 4: Auto-Detect Errors (~3 hours)

**Goal:** Automatically record errors from failed tools

**Files:**
- Modify: `src/core/HookIntegration.ts` (detect failed tools)
- Modify: `src/memory/ProjectAutoTracker.ts` (add `recordError()`)

**Error detection in HookIntegration:**
```typescript
// In HookIntegration.ts
async detectCheckpointFromToolUse(
  toolData: ToolUseData
): Promise<Checkpoint | null> {
  // NEW: Detect errors from failed tools
  if (!toolData.success) {
    return {
      name: 'error-encountered',
      data: {
        tool: toolData.toolName,
        arguments: toolData.arguments,
        error_output: toolData.output,
        duration: toolData.duration,
      },
    };
  }

  // Existing checkpoint detection...
}
```

**Memory structure:**
```typescript
// In ProjectAutoTracker.ts
async recordError(data: {
  tool: string;
  arguments?: unknown;
  error_output?: string;
  error_type?: string;  // From systematic-debugging
  root_cause?: string;
  solution?: string;
  prevention?: string;
}): Promise<void> {
  const timestamp = new Date().toISOString();
  const dateStr = timestamp.split('T')[0];

  const observations: string[] = [
    `ERROR: ${data.tool} tool failed`,
    data.error_output ? `OUTPUT: ${data.error_output.substring(0, 200)}` : '',
    data.error_type ? `TYPE: ${data.error_type}` : '',
    data.root_cause ? `ROOT CAUSE: ${data.root_cause}` : '',
    data.solution ? `SOLUTION: ${data.solution}` : '',
    data.prevention ? `PREVENTION: ${data.prevention}` : '',
  ].filter(Boolean);

  await this.mcp.createEntities([{
    name: `Error: ${data.tool} - ${dateStr}`,
    entityType: 'error_resolution',
    observations,
    metadata: {
      timestamp,
      tool: data.tool,
      arguments: data.arguments,
      error_type: data.error_type,
      root_cause: data.root_cause,
      solution: data.solution,
      prevention: data.prevention,
    },
  }]);
}
```

**Integration with systematic-debugging skill:**
```markdown
## After finding root cause and solution:

Use CCB to record the error resolution:
```
ccb-record-error with:
- error_type: "config"
- root_cause: "Default path was process.cwd()/data/ instead of ~/.claude-code-buddy/"
- solution: "Fixed path to use homedir() in both create() and createSync()"
- prevention: "Add path validation in constructor, test database initialization"
```
```

**Acceptance:**
- [ ] Failed tools auto-create `error_resolution` entity
- [ ] Error output captured
- [ ] Manual trigger via ccb-record-error works
- [ ] Manual test: fail a tool, verify memory

---

### Task 5: Add Entity Type Enum (~1 hour)

**Goal:** Define all memory entity types in one place

**Files:**
- Modify: `src/knowledge-graph/types.ts` (add entity type enum)

**New enum:**
```typescript
// In types.ts
export enum EntityType {
  // Existing types
  DECISION = 'decision',
  FEATURE = 'feature',
  BUG_FIX = 'bug_fix',
  CODE_CHANGE = 'code_change',
  TEST_RESULT = 'test_result',
  ARCHITECTURE_DECISION = 'architecture_decision',

  // NEW: Phase 0.6 types
  TASK_START = 'task_start',
  PROGRESS_MILESTONE = 'progress_milestone',
  ERROR_RESOLUTION = 'error_resolution',

  // Existing auto-tracker types
  CODE_COMMIT = 'code_commit',
  PHASE_COMPLETE = 'phase_complete',
  TOKEN_SNAPSHOT = 'token_snapshot',
}
```

**Acceptance:**
- [ ] All entity types defined in enum
- [ ] Existing code uses enum
- [ ] New tools use enum

---

### Task 6: Update Skills Documentation (~2 hours)

**Goal:** Document new memory tools in skills

**Files:**
- Modify: `~/.claude/skills/superpowers/executing-plans/SKILL.md`
- Modify: `~/.claude/skills/superpowers/systematic-debugging/SKILL.md`
- Modify: `~/.claude/skills/superpowers/writing-plans/SKILL.md`

**executing-plans additions:**
```markdown
## Memory Recording (Phase 0.6 Enhancement)

**Task Start** - Automatically recorded when plan execution starts
**After each major task:**
- Use `ccb-record-milestone` to track progress
- Include: milestone, progress %, next steps, blockers, learnings

**After decisions:**
- Use `ccb-record-decision` for important choices
- Include: decision, alternatives, reasoning, impact
```

**systematic-debugging additions:**
```markdown
## Memory Recording (Phase 0.6 Enhancement)

**After finding root cause:**
- Use `ccb-record-error` (or auto-recorded from failed tools)
- Include: error type, root cause, solution, prevention method
```

**Acceptance:**
- [ ] All skills document new memory tools
- [ ] Examples provided
- [ ] Usage guidelines clear

---

### Task 7: Testing & Validation (~3 hours)

**Test scenarios:**

1. **Task Start Auto-Record**
   - Start task via buddy-do
   - Verify `task_start` entity created
   - Check goal/reason extracted

2. **Decision Recording**
   - Use `ccb-record-decision`
   - Verify `decision` entity with alternatives

3. **Milestone Tracking**
   - Use `ccb-record-milestone`
   - Verify `progress_milestone` entity

4. **Auto Error Detection**
   - Fail a tool (e.g., Edit with bad old_string)
   - Verify `error_resolution` entity auto-created

5. **End-to-End Workflow**
   - Complete full development cycle
   - Verify complete memory timeline:
     - Task start ‚Üí Code changes ‚Üí Milestones ‚Üí Decisions ‚Üí Errors ‚Üí Commits

6. **Memory Recall**
   - Use `buddy-remember` to recall:
     - "What are we working on?" ‚Üí task_start memories
     - "What decisions did we make?" ‚Üí decision memories
     - "What's our progress?" ‚Üí progress_milestone memories
     - "What errors did we fix?" ‚Üí error_resolution memories

**Acceptance:**
- [ ] All test scenarios pass
- [ ] Memory timeline complete
- [ ] Recall works for all entity types

---

### Task 8: Documentation (~2 hours)

**Files:**
- Create: `docs/features/enhanced-auto-memory.md`
- Modify: `README.md` (update auto-memory features)
- Modify: `CHANGELOG.md` (Phase 0.6 entry)

**Documentation includes:**
- Overview of enhanced auto-memory
- New entity types (task_start, decision, progress_milestone, error_resolution)
- New MCP tools (ccb-record-decision, ccb-record-milestone, ccb-record-error)
- Integration with existing workflows
- Usage examples
- Best practices

**Acceptance:**
- [ ] All docs updated
- [ ] Examples work as documented

---

## üìä Estimation Summary

| Task | Hours | Lines of Code |
|------|-------|---------------|
| 1. Task Start Tracking | 3 | 150 |
| 2. Decision Tracking | 3 | 120 |
| 3. Milestone Tracking | 2 | 100 |
| 4. Auto Error Detection | 3 | 100 |
| 5. Entity Type Enum | 1 | 30 |
| 6. Skills Documentation | 2 | - |
| 7. Testing & Validation | 3 | - |
| 8. Documentation | 2 | - |
| **Total** | **19 hours** | **~500 lines** |

**Risk Level:** Low (extends existing system, no breaking changes)

---

## ‚úÖ Success Criteria

**Phase 0.6 is complete when:**

- [ ] Task start auto-recorded with goal, reason, expected outcome
- [ ] Decisions captured with alternatives and reasoning
- [ ] Progress milestones tracked with %, next steps, blockers
- [ ] Errors auto-detected and recorded
- [ ] All new entity types defined in enum
- [ ] Skills documentation updated
- [ ] All tests pass
- [ ] Complete memory timeline:
  ```
  buddy-remember "what are we working on?"
  ‚Üí Shows: Task goal, decisions made, current progress, errors fixed
  ```
- [ ] README and CHANGELOG updated

---

## üéØ Expected Impact

**Before Phase 0.6:**
```
User: "What were we working on?"
CCB: [recalls code changes, test results, commits]
"We modified 5 files, tests passed, committed changes."
‚ùå Missing: WHY we did it, WHAT the goal was, WHERE we are in progress
```

**After Phase 0.6:**
```
User: "What were we working on?"
CCB: [recalls complete timeline]
"‚úÖ TASK: Implement A2A Protocol Phase 0.5 (started 2026-01-31 10:30)

GOAL: Enable agent-to-agent communication for multi-step workflows
REASON: Need Claude instances to collaborate on complex tasks
EXPECTED: 2+ Claude instances can send tasks and get results

üìä PROGRESS:
- Milestone: Task 2/10 complete (20%)
- Last: Task Queue Storage implemented
- Next: Implement Agent Registry

üí° DECISIONS:
- Use SQLite for Task Queue instead of Knowledge Graph
  Reasoning: Better separation of concerns

üêõ ERRORS FIXED:
- Knowledge Graph path bug
  Root Cause: Wrong default path
  Solution: Use homedir() instead of process.cwd()

üìù CODE CHANGES:
- Modified 5 files, tests passed, committed changes
"
```

---

**Plan Status:** Ready for review
**Branch:** `feature/phase-0.5-a2a-protocol` (can work in parallel)
**Dependencies:** None (pure extension of existing system)
